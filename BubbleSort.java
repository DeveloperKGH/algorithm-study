import java.util.Collections;
import java.util.List;

/*
 * 버블 정렬
 * 두 인접한 데이터를 비교하여 일정한 기준을 만족하면 서로의 자리를 변경 (거품이 일어나는 모습과 비슷하다고 해서 버블정렬)
 * 오름차순 : 두 인접한 데이터를 비교하여 앞쪽의 값이 더 크다면 서로의 자리를 변경
 * 내림차순 : 두 인접한 데이터를 비교하여 뒤쪽의 값이 더 크다면 서로의 자리를 변경

 * ex) 오름차순 정렬 동작 point
 * 규칙1 : n개의 리스트가 있는 경우, 버블정렬의 반복 횟수는 최대 n-1 번 (로직이 1번씩 적용 될때마다 가장 큰 숫자가 맨 뒤에서 결정됨)
 * 규칙2 : n개의 리스트가 있는 경우, 버블정렬 비교횟수 : (n-1) + (n-2) + ... + 1 (총 비교횟수 : n*(n-1)/2 )
 * 규칙3 : 로직이 일찍 끝날 수 도 있음 (ex : 이미 정렬된 경우). 따라서, 로직 적용 시 한번도 데이터가 교환된 적이 없다면, 이미 정렬된 상태이므로 로직을 더이상 적용 할 필요 없음

 * 버블 정렬의 시간 복잡도 : O(n^2) (최선의 경우 O(n) 까지도 낮출수 있음)
 * 안좋은 시간복잡도 때문에 실무에서는 보통 쓰이지 않음
 */

public class BubbleSort {

    public List<Integer> sort(List<Integer> list) {

        // n개의 리스트가 있는 경우 최대 n-1 번의 버블정렬 단계 적용
        for (int i = 0; i < list.size() - 1; i++) {
            boolean swap = false;

            /*
            * j 인덱스와 j+1 인덱스의 값을 비교하여 큰 수를 뒤쪽에 정렬
            * 로직이 1번씩 적용 될때마다 가장 큰 숫자가 맨 뒤에서 결정
            * 따라서, 각각의 버블정렬 단계에서 비교횟수는 1씩 감소
            * */
            for (int j = 0; j < list.size() - 1 - i; j++) {
                if (list.get(j) > list.get(j + 1)) {
                    Collections.swap(list, j, j+1);
                    swap = true;
                }
            }

            //로직 적용 시 한번도 데이터가 교환된 적이 없다면, 이미 정렬된 상태이므로 로직을 더이상 적용 할 필요 없음
            if (!swap) break;

        }

        return list;
    }

}
